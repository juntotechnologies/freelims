name: FreeLIMS Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, macos-latest]
        python-version: ['3.9', '3.10']
      fail-fast: false

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Ensure script is executable
      run: chmod +x freelims.sh
      shell: bash
      
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r tests/requirements.txt
        # Install backend dependencies for API tests
        pip install -r backend/requirements.txt
        # Additional dependencies for test/python directory
        pip install python-socketio requests "python-socketio[asyncio_client]"
      shell: bash
        
    - name: Configure environment for Python tests
      run: |
        # Create a mock version of the socketio module in the test dir
        mkdir -p test/python/mocks
        touch test/python/mocks/__init__.py
        echo "# Mock SocketIO module for testing" > test/python/mocks/socketio_mock.py
        echo "class AsyncServer:" >> test/python/mocks/socketio_mock.py
        echo "    def __init__(self, async_mode='asgi', cors_allowed_origins='*'):" >> test/python/mocks/socketio_mock.py
        echo "        self.async_mode = async_mode" >> test/python/mocks/socketio_mock.py
        echo "        self.cors_allowed_origins = cors_allowed_origins" >> test/python/mocks/socketio_mock.py
        echo "" >> test/python/mocks/socketio_mock.py
        echo "    async def emit(self, event, data, room=None):" >> test/python/mocks/socketio_mock.py
        echo "        print(f\"Mock emit: {event}, {data}, room={room}\")" >> test/python/mocks/socketio_mock.py
        echo "        return True" >> test/python/mocks/socketio_mock.py
        echo "" >> test/python/mocks/socketio_mock.py
        echo "class ASGIApp:" >> test/python/mocks/socketio_mock.py
        echo "    def __init__(self, sio, socketio_path=''):" >> test/python/mocks/socketio_mock.py
        echo "        self.sio = sio" >> test/python/mocks/socketio_mock.py
        echo "        self.socketio_path = socketio_path" >> test/python/mocks/socketio_mock.py
      shell: bash
        
    - name: Create directory structure for tests
      run: |
        mkdir -p logs
        mkdir -p scripts/system/dev
        mkdir -p scripts/system/prod
        mkdir -p service_files
        mkdir -p launch_files
        
        # Create files for Linux integration test
        touch scripts/system/dev/run_dev_backend.sh
        touch scripts/system/dev/run_dev_frontend.sh
        touch service_files/freelims-dev-backend.service
        touch service_files/freelims-dev-frontend.service
        
        # Make script files executable
        chmod +x scripts/system/dev/run_dev_backend.sh 2>/dev/null || true
        chmod +x scripts/system/dev/run_dev_frontend.sh 2>/dev/null || true
      shell: bash
        
    - name: Create test port_config.sh
      run: |
        mkdir -p $(dirname port_config.sh)
        echo "#!/bin/bash" > port_config.sh
        echo "# FreeLIMS Port Configuration (for testing)" >> port_config.sh
        echo "DEV_BACKEND_PORT=8801" >> port_config.sh
        echo "DEV_FRONTEND_PORT=3801" >> port_config.sh
        echo "PROD_BACKEND_PORT=8802" >> port_config.sh
        echo "PROD_FRONTEND_PORT=3802" >> port_config.sh
        echo "" >> port_config.sh
        echo "# Check if a port is in use" >> port_config.sh
        echo "is_port_in_use() {" >> port_config.sh
        echo "    local port=$1" >> port_config.sh
        echo "    if command -v lsof >/dev/null 2>&1; then" >> port_config.sh
        echo "        if lsof -i :$port -t >/dev/null 2>&1; then" >> port_config.sh
        echo "            return 0  # Port is in use" >> port_config.sh
        echo "        else" >> port_config.sh
        echo "            return 1  # Port is free" >> port_config.sh
        echo "        fi" >> port_config.sh
        echo "    elif command -v netstat >/dev/null 2>&1; then" >> port_config.sh
        echo "        if netstat -tuln | grep -q ":$port "; then" >> port_config.sh
        echo "            return 0  # Port is in use" >> port_config.sh
        echo "        else" >> port_config.sh
        echo "            return 1  # Port is free" >> port_config.sh
        echo "        fi" >> port_config.sh
        echo "    else" >> port_config.sh
        echo "        echo "Error: Cannot check port usage; neither lsof nor netstat available."" >> port_config.sh
        echo "        return 2  # Error condition" >> port_config.sh
        echo "    fi" >> port_config.sh
        echo "}" >> port_config.sh
        echo "" >> port_config.sh
        echo "# Get the process IDs using a specific port" >> port_config.sh
        echo "get_process_on_port() {" >> port_config.sh
        echo "    local port=$1" >> port_config.sh
        echo "    if command -v lsof >/dev/null 2>&1; then" >> port_config.sh
        echo "        lsof -i :$port -t" >> port_config.sh
        echo "    elif command -v netstat >/dev/null 2>&1 && command -v grep >/dev/null 2>&1 && command -v awk >/dev/null 2>&1; then" >> port_config.sh
        echo "        netstat -tuln | grep ":$port " | awk '{print $7}'" >> port_config.sh
        echo "    else" >> port_config.sh
        echo "        echo "Error: Cannot get process; neither lsof nor netstat available."" >> port_config.sh
        echo "        return 1" >> port_config.sh
        echo "    fi" >> port_config.sh
        echo "}" >> port_config.sh
        echo "" >> port_config.sh
        echo "# Kill a process safely" >> port_config.sh
        echo "safe_kill_process_on_port() {" >> port_config.sh
        echo "    local port=$1" >> port_config.sh
        echo "    local force=$2" >> port_config.sh
        echo "    " >> port_config.sh
        echo "    local pids=$(get_process_on_port $port)" >> port_config.sh
        echo "    if [ -z "$pids" ]; then" >> port_config.sh
        echo "        echo "No process found on port $port"" >> port_config.sh
        echo "        return 1" >> port_config.sh
        echo "    fi" >> port_config.sh
        echo "    " >> port_config.sh
        echo "    for pid in $pids; do" >> port_config.sh
        echo "        if [ "$force" = "yes" ]; then" >> port_config.sh
        echo "            kill -9 $pid 2>/dev/null" >> port_config.sh
        echo "            echo "Force killed process $pid on port $port"" >> port_config.sh
        echo "        else" >> port_config.sh
        echo "            kill $pid 2>/dev/null" >> port_config.sh
        echo "            echo "Terminated process $pid on port $port"" >> port_config.sh
        echo "        fi" >> port_config.sh
        echo "    done" >> port_config.sh
        echo "    " >> port_config.sh
        echo "    return 0" >> port_config.sh
        echo "}" >> port_config.sh
        
        # Make script executable
        chmod +x port_config.sh 2>/dev/null || true
      shell: bash
        
    - name: Run unit tests
      run: |
        pytest tests/unit/ -v
      shell: bash
        
    - name: Create dummy script files for integration tests
      run: |
        mkdir -p scripts/system
        echo "#!/bin/bash" > scripts/system/manage.sh
        echo "# Dummy manage.sh for testing" >> scripts/system/manage.sh
        echo "" >> scripts/system/manage.sh
        echo "# Environment variables used" >> scripts/system/manage.sh
        echo "DEV_BACKEND_PORT=${DEV_BACKEND_PORT:-8001}" >> scripts/system/manage.sh
        echo "DEV_FRONTEND_PORT=${DEV_FRONTEND_PORT:-3001}" >> scripts/system/manage.sh
        echo "PROD_BACKEND_PORT=${PROD_BACKEND_PORT:-8002}" >> scripts/system/manage.sh
        echo "PROD_FRONTEND_PORT=${PROD_FRONTEND_PORT:-3002}" >> scripts/system/manage.sh
        echo "" >> scripts/system/manage.sh
        echo "manage_system() {" >> scripts/system/manage.sh
        echo "    local env=$1" >> scripts/system/manage.sh
        echo "    local cmd=$2" >> scripts/system/manage.sh
        echo "    " >> scripts/system/manage.sh
        echo "    echo "Managing system: $env $cmd"" >> scripts/system/manage.sh
        echo "    " >> scripts/system/manage.sh
        echo "    case "$cmd" in" >> scripts/system/manage.sh
        echo "        start)" >> scripts/system/manage.sh
        echo "            echo "Starting $env environment"" >> scripts/system/manage.sh
        echo "            return 0" >> scripts/system/manage.sh
        echo "            ;;
        echo "        stop)" >> scripts/system/manage.sh
        echo "            echo "Stopping $env environment"" >> scripts/system/manage.sh
        echo "            return 0" >> scripts/system/manage.sh
        echo "            ;;
        echo "        restart)" >> scripts/system/manage.sh
        echo "            echo "Restarting $env environment"" >> scripts/system/manage.sh
        echo "            return 0" >> scripts/system/manage.sh
        echo "            ;;
        echo "        status)" >> scripts/system/manage.sh
        echo "            echo "Status of $env environment"" >> scripts/system/manage.sh
        echo "            echo "Environment Status: OK (mock)"" >> scripts/system/manage.sh
        echo "            return 0" >> scripts/system/manage.sh
        echo "            ;;
        echo "        *)" >> scripts/system/manage.sh
        echo "            echo "Unknown command: $cmd"" >> scripts/system/manage.sh
        echo "            return 1" >> scripts/system/manage.sh
        echo "            ;;
        echo "    esac" >> scripts/system/manage.sh
        echo "}" >> scripts/system/manage.sh
        
        mkdir -p scripts/db
        echo "#!/bin/bash" > scripts/db/manage.sh
        echo "# Dummy db/manage.sh for testing" >> scripts/db/manage.sh
        echo "" >> scripts/db/manage.sh
        echo "manage_database() {" >> scripts/db/manage.sh
        echo "    local env=$1" >> scripts/db/manage.sh
        echo "    local cmd=$2" >> scripts/db/manage.sh
        echo "    " >> scripts/db/manage.sh
        echo "    echo "Managing database: $env $cmd"" >> scripts/db/manage.sh
        echo "    " >> scripts/db/manage.sh
        echo "    case "$cmd" in" >> scripts/db/manage.sh
        echo "        backup)" >> scripts/db/manage.sh
        echo "            echo "Backing up $env database"" >> scripts/db/manage.sh
        echo "            return 0" >> scripts/db/manage.sh
        echo "            ;;
        echo "        restore)" >> scripts/db/manage.sh
        echo "            echo "Restoring $env database"" >> scripts/db/manage.sh
        echo "            return 0" >> scripts/db/manage.sh
        echo "            ;;
        echo "        init)" >> scripts/db/manage.sh
        echo "            echo "Initializing $env database"" >> scripts/db/manage.sh
        echo "            return 0" >> scripts/db/manage.sh
        echo "            ;;
        echo "        migrate)" >> scripts/db/manage.sh
        echo "            echo "Migrating $env database"" >> scripts/db/manage.sh
        echo "            return 0" >> scripts/db/manage.sh
        echo "            ;;
        echo "        *)" >> scripts/db/manage.sh
        echo "            echo "Unknown command: $cmd"" >> scripts/db/manage.sh
        echo "            return 1" >> scripts/db/manage.sh
        echo "            ;;
        echo "    esac" >> scripts/db/manage.sh
        echo "}" >> scripts/db/manage.sh
        
        mkdir -p scripts/user
        echo "#!/bin/bash" > scripts/user/manage.sh
        echo "# Dummy user/manage.sh for testing" >> scripts/user/manage.sh
        echo "" >> scripts/user/manage.sh
        echo "manage_users() {" >> scripts/user/manage.sh
        echo "    local env=$1" >> scripts/user/manage.sh
        echo "    local cmd=$2" >> scripts/user/manage.sh
        echo "    " >> scripts/user/manage.sh
        echo "    echo "Managing users: $env $cmd"" >> scripts/user/manage.sh
        echo "    " >> scripts/user/manage.sh
        echo "    case "$cmd" in" >> scripts/user/manage.sh
        echo "        list)" >> scripts/user/manage.sh
        echo "            echo "Listing users in $env"" >> scripts/user/manage.sh
        echo "            return 0" >> scripts/user/manage.sh
        echo "            ;;
        echo "        create)" >> scripts/user/manage.sh
        echo "            echo "Creating user in $env"" >> scripts/user/manage.sh
        echo "            return 0" >> scripts/user/manage.sh
        echo "            ;;
        echo "        delete)" >> scripts/user/manage.sh
        echo "            echo "Deleting user in $env"" >> scripts/user/manage.sh
        echo "            return 0" >> scripts/user/manage.sh
        echo "            ;;
        echo "        clear)" >> scripts/user/manage.sh
        echo "            echo "Clearing users in $env"" >> scripts/user/manage.sh
        echo "            return 0" >> scripts/user/manage.sh
        echo "            ;;
        echo "        *)" >> scripts/user/manage.sh
        echo "            echo "Unknown command: $cmd"" >> scripts/user/manage.sh
        echo "            return 1" >> scripts/user/manage.sh
        echo "            ;;
        echo "    esac" >> scripts/user/manage.sh
        echo "}" >> scripts/user/manage.sh
        
        # Make scripts executable
        chmod +x scripts/system/manage.sh 2>/dev/null || true
        chmod +x scripts/db/manage.sh 2>/dev/null || true
        chmod +x scripts/user/manage.sh 2>/dev/null || true
      shell: bash
        
    - name: Run integration tests with mocked components
      run: |
        pytest tests/integration/ -v --junitxml=test-results.xml
      shell: bash
        
    - name: Generate coverage report
      run: |
        # Exclude the Python test directory when generating coverage
        pytest --cov=. --cov-report=xml --ignore=test/python/ --ignore=venv/
      shell: bash
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.os }}-${{ matrix.python-version }}
        path: test-results.xml
      if: always()
      
    - name: Upload coverage report
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        fail_ci_if_error: false 